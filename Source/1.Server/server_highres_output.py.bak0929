# server_highres_output.py (컴퓨터에서 실행)
import socket
import cv2
# import pickle # pickle은 더 이상 사용하지 않음
import struct
import threading
import time
import numpy as np # numpy 모듈 추가
import torch # torch 모듈 추가
from flask import Flask, Response
from ultralytics import YOLO

# --- 1. 영상 수신 및 객체 탐지 파트 ---
# Load YOLOv8 model
device = 'cuda' if torch.cuda.is_available() else 'cpu' # CUDA 사용 가능 여부 확인
#model = YOLO('/home/bbang/Workspace/intel_final/intel_final_project/runs/detect/yolov8x_tomato3/weights/best.pt').to(device) # 모델을 해당 장치로 로드
model = YOLO('/home/bbang/Workspace/intel_final/intel_final_project/runs/detect/yolov8x_tomato10/weights/best.pt').to(device) # 모델을 해당 장치로 로드

print(f"YOLOv8 모델을 {device} 장치로 로드했습니다.") # 로드된 장치 출력

# 최신 처리된 프레임을 저장할 변수
output_frame = None
lock = threading.Lock()

def handle_client(conn, addr):
    """클라이언트로부터 영상을 받아 처리하는 함수"""
    global output_frame
    conf_threshold = 0.6
    print(f"클라이언트 {addr}가 연결되었습니다.")
    
    data = b""
    payload_size = struct.calcsize(">L")

    # FPS calculation variables
    fps_start_time = time.time()
    fps_frame_count = 0
    display_fps = 0

    while True:
        try:
            # 설정한 payload_size 만큼의 데이터를 먼저 받음 (프레임 크기 정보)
            while len(data) < payload_size:
                packet = conn.recv(4*1024)
                if not packet: raise ConnectionAbortedError
                data += packet
            
            packed_msg_size = data[:payload_size]
            data = data[payload_size:]
            msg_size = struct.unpack(">L", packed_msg_size)[0]

            # 실제 프레임 데이터를 모두 수신
            while len(data) < msg_size:
                data += conn.recv(4*1024)
            
            frame_data = data[:msg_size]
            data = data[msg_size:]

            # JPEG 프레임 역직렬화
            frame_array = np.frombuffer(frame_data, dtype=np.uint8)
            frame = cv2.imdecode(frame_array, cv2.IMREAD_COLOR)
            
            if frame is None: # 디코딩 실패 시 건너뛰기
                print("오류: JPEG 프레임 디코딩 실패")
                continue

            # Original frame dimensions
            h_orig, w_orig, _ = frame.shape

            # Dimensions for YOLO inference
            yolo_w = 640
            yolo_h = int(yolo_w * (h_orig / w_orig)) # Calculate height to preserve aspect ratio
            resized_frame_for_yolo = cv2.resize(frame, (yolo_w, yolo_h)) # This is the frame YOLO sees

            # YOLOv8 Inference on the resized frame
            results = model(resized_frame_for_yolo, verbose=False)

            # Prepare rendered_frame as a copy of the original high-res frame
            rendered_frame = frame.copy()

            # Calculate scaling factors from YOLO input size to original frame size
            scale_x = w_orig / yolo_w
            scale_y = h_orig / yolo_h

            # Manually draw bounding boxes using normalized coordinates
            for box in results[0].boxes:
                conf = box.conf[0]
                # 신뢰도 임계값 체크
                if conf < conf_threshold:
                    continue

                # Get normalized coordinates (xyxyn) relative to resized_frame_for_yolo
                nx1, ny1, nx2, ny2 = box.xyxyn[0]
                
                # Convert to pixel coordinates relative to resized_frame_for_yolo
                # Then scale them to the original frame's dimensions
                x1 = int(nx1 * yolo_w * scale_x)
                y1 = int(ny1 * yolo_h * scale_y)
                x2 = int(nx2 * yolo_w * scale_x)
                y2 = int(ny2 * yolo_h * scale_y)
                
                cls = int(box.cls[0])
                class_name = model.names[cls]
                label = f"{class_name} {conf:.2f}"

                # 'ripe' 또는 'rotten'이 감지되면 클라이언트로 좌표 전송
                if class_name in ['ripe', 'rotten']:
                    try:
                        message = f"{class_name}:{x1},{y1}"
                        conn.sendall(message.encode('utf-8'))
                    except socket.error as e:
                        print(f"클라이언트로 메시지 전송 실패: {e}")
                
                cv2.rectangle(rendered_frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                # Scale font size for the label
                label_font_scale = 0.5 * (w_orig / yolo_w)
                cv2.putText(rendered_frame, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, label_font_scale, (0, 255, 0), 2)

            # FPS calculation
            fps_frame_count += 1
            if time.time() - fps_start_time >= 1.0:
                display_fps = fps_frame_count / (time.time() - fps_start_time)
                fps_frame_count = 0
                fps_start_time = time.time()

            # Display FPS on the frame
            # Scale font size for FPS display
            fps_font_scale = 0.7 * (w_orig / yolo_w)
            cv2.putText(rendered_frame, f"FPS: {display_fps:.2f}", (20, 50), cv2.FONT_HERSHEY_SIMPLEX, fps_font_scale, (0, 0, 255), 2)

            # 처리된 프레임을 공유 변수에 저장
            with lock:
                output_frame = rendered_frame.copy()
        except (ConnectionAbortedError, ConnectionResetError, struct.error): # pickle.UnpicklingError 제거
            break


    print(f"클라이언트 {addr} 연결이 끊겼습니다.")
    conn.close()

def start_socket_server():
    """여러 라즈베리 파이의 연결을 기다리는 소켓 서버"""
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('0.0.0.0', 9999))
    server_socket.listen(10)
    print("소켓 서버가 시작되었습니다. 클라이언트의 연결을 기다립니다...")

    while True:
        conn, addr = server_socket.accept()
        # 클라이언트마다 새로운 스레드를 생성하여 처리
        thread = threading.Thread(target=handle_client, args=(conn, addr))
        thread.daemon = True
        thread.start()

# --- 2. Flask 웹 스트리밍 파트 ---
app = Flask(__name__)

def generate_frames():
    """처리된 프레임을 웹으로 스트리밍하는 함수"""
    global output_frame
    while True:
        with lock:
            if output_frame is None:
                continue
            
            # 프레임을 JPEG으로 인코딩
            (flag, encodedImage) = cv2.imencode(".jpg", output_frame)
            if not flag:
                continue

        # 클라이언트에게 전송
        yield(b'--frame\r\n' b'Content-Type: image/jpeg\r\n\r\n' + 
              bytearray(encodedImage) + b'\r\n')

@app.route("/video_feed")
def video_feed():
    return Response(generate_frames(),
                    mimetype = "multipart/x-mixed-replace; boundary=frame")

@app.route("/")
def index():
    # 간단한 웹페이지. templates/index.html 파일을 만들어야 합니다.
    return "<h1>토마토 감지 가뵤자고~</h1><img src='/video_feed'>"


if __name__ == '__main__':
    # 소켓 서버를 별도의 스레드에서 실행
    socket_thread = threading.Thread(target=start_socket_server)
    socket_thread.daemon = True
    socket_thread.start()

    # Flask 앱 실행
    app.run(host='0.0.0.0', port=5000, debug=False)
